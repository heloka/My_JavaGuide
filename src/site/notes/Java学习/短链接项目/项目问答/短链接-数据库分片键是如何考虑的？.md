---
{"dg-publish":true,"permalink":"/Java学习/短链接项目/项目问答/短链接-数据库分片键是如何考虑的？/"}
---

## 什么是分片键  
分片键是一种用来将数据库（表）水平拆分的数据库字段。例入：将订单表中的订单主键的尾数取模分片，则订单主键为分片字段。 SQL 中如果无分片字段，将执行全路由，性能较差。  
简单来说，我们将短链接表拆分了 16 张分表，那用户新增短链接，怎么知道短链接记录**应该放到哪张表里**？这就需要用到分片键了，通过分片键进行一定规则（短链接表 t_link 使用的是 HASH_MOD 方式）的运算，最终得到一个下标，这也就是我们要插入的分表位置。  
得到一个下标指的是从 0-15 获取值，然后和 t_link_(**i**) 一拼接，就是我们 MySQL 数据库中的真实表名称。  
[分库分表之分片键 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/609637884)
## 真实业务场景  
对数据库分表后，在执行 SQL 查询时，必须要带上分片键，否则会导致**全路由**，数据库会在所有分片表中查找数据，增加了查询时间和资源消耗，性能较差。  

为什么不用 `full_short_url` 分片呢，这样还可以少个路由表。在真实业务场景，这个是行不通的。  
根据我们的功能原型得知，短链接是根据分组访问的，那么查询条件中就必须要带一个 Gid。如果我们按照**短链接字段**进行分表，相当于在**分页查询接口**中没有分片键 Gid 字段，就会扫描全部分片表，出现读扩散问题。 
ps：还是没懂，就算我们不用 Gid 作为分片键，应该也没问题吧，用短链接作为分片键，分页查询还是能用 Gid 吧
- 说不通，我觉得果然还是短链接监控汇总哪方面的原因吧。
![Pasted image 20240325154951.png](/img/user/image/Pasted%20image%2020240325154951.png)
![image/72a4b67f45303bf2480fa63e81030234_MD5.webp](/img/user/image/72a4b67f45303bf2480fa63e81030234_MD5.webp)

  
那 `t_link_goto` 表是做什么的呢？  
用户通过浏览器访问短链接时，仅有短链接值，没有 Gid 的，所以我们就要建立个路由表，也就是 t_link_goto 是用来缓存短链接和 Gid 的对应关系的。  

![Pasted image 20240325155133.png](/img/user/image/Pasted%20image%2020240325155133.png)

通过短链接的 `full_short_url` 查询 t_link_goto 表，获取到对应的 Gid，**进而**再去查询 t_link 表，这样就不会出现读扩散问题。
![Pasted image 20240325160139.png](/img/user/image/Pasted%20image%2020240325160139.png)


## 附录
### 读扩散
很多同学对于读扩散问题可能不太了解，这里举个栗子。  
我们期望在输入一个短链接后，去 MySQL 数据库查询是这样执行的，精确到具体的数据库分片表。  
```sql
select * from t_link_x(0-15) where full_short_url = 'xxx'
```
不好意思，因为你没有用 Gid 分片键，那么迎接你的，将是分库分表的审判。  
![image/Pasted image 20240328165935.png](/img/user/image/Pasted%20image%2020240328165935.png)

ShardingSphere 底层会从所有分片表中进行查询，直到过滤出你需要的数据进行归并。大家想一下，从一张表里查询，和从这么多表里查询，性能孰强孰弱？所以我们使用分表后，一定要带上分片键进行查询。  



### **t-link 表信息**
![Pasted image 20240325161002.png](/img/user/image/Pasted%20image%2020240325161002.png)

### 短链接库表结构
[[Java学习/短链接项目/项目问答/短链接跳转原始链接功能#^2m3g20\|短链接跳转原始链接功能#^2m3g20]]