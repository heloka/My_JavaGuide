---
{"dg-publish":true,"permalink":"/Java学习/短链接项目/项目问答/短链接-短链接哈希算法生成冲突问题如何解决？/"}
---

**可能问法**：
- 短链接如何生成的？


## 使用的什么方式生成短链接？

主要分为两个方面，通过 Hash 算法将原始连接转换成一个 Hash 码，这里使用了 Google 出品的 MurmurHash 算法。
由于生成的 Hash 码是十进制的，整体较长不利于短链接传播。因此，我们将十进制转换为 62 进制，生成了最终的短链接。  

### 1. MurmurHash 算法  
对于哈希函数的选择，有很多人可能会使用 MD5、SHA 等加密算法。不过这里我们并不关心反向解密的难度，更重要的是关注哈希的运算速度和冲突概率。  
本项目最终选择使用了 Google 开发的 MurmurHash 算法。MurmurHash 是一种**非加密型**哈希函数，适用于一般的哈希检索操作。与其他流行的哈希函数相比，MurmurHash 在处理规律性较强的键时具有更好的随机分布特性。由于它是非加密型的，相比 MD5、SHA 等加密算法，MurmurHash 的性能要高得多（实际上是 MD5 等加密算法的十倍以上）。正是由于这些优点，尽管它于 2008 年问世，但目前已广泛应用于 Redis、MemCache、Cassandra、HBase、Lucene 等许多知名软件中。  
我们使用 Hutool 里的工具类，不过他的底层也是使用的 Google 算法。  
  ![image/Pasted image 20240328153137.png](/img/user/image/Pasted%20image%2020240328153137.png)
使用 hash 算法进行一次 Hash 转换后，得到的值整体还是比较长，要再次进行缩减。  

### 2. 进制转换  
Base62 编码是将数据转换为只包含数字和字母的一种方法。它使用了 62 个字符，分别是 0-9、a-z、A-Z，可以作为 URL 短链接、文件名等场景的字符串表示，相对于 16 进制或 64 进制等其他编码，Base62 具有更高的可读性和稳定性。  


>假设我们使用的是 26 个字母的大小写，加上 10 个数字，那么短链接可以表示的最大组合数量为：  
●N = 4，组合数为 62 ^ 4 = 14_776_336，1477 万左右。  
●N = 5，组合数为 62 ^ 5 = 916_132_832，9.16 亿左右。  
●N = 6，组合数为 62 ^ 6 = 56_800_235_584，568 亿左右。  

![image/041e9b57d4c6ac63acb624ae458f0a9d_MD5.webp](/img/user/image/041e9b57d4c6ac63acb624ae458f0a9d_MD5.webp)


有个注意事项，Hash 值可能有负数，通过负数进行 Base62 转换会得到空字符串，所以我们要进行判断。  
```java
//核心步骤，hash如果为负数，在62进制转换前变为整数。
long actualHash32 = hash32 < 0 ? 
Integer.MAX_VALUE - (long) hash32 : hash32; 
String shortLink = convertDecToBase62(actualHash32); 

```

## 为什么会冲突？  
哈希函数将输入的数据映射为一个固定长度的哈希值，然而**不同的输入可能会映射为相同的哈希值**，这被称为哈希冲突。  
在短链接生成过程中，原始长链接经过哈希函数进行计算，生成一个哈希值。如果两个不同的原始长链接经过哈希计算后得到相同的哈希值，那么它们将生成相同的短链接。  
这种情况通常是由于哈希函数的输出空间有限，而输入空间却是无限的。因此，无论哈希函数的设计有多好，仍然存在一定的概率会出现冲突。  

## 为什么使用原始链接和 UUID 生成短链接？  
生成的短链接需要确保在当前域名下是**唯一**的，那这个唯一又如何体现呢？每次查询数据库中已有短链接数据来判断是否唯一么？这样可能会产生性能问题，所以我们使用了布隆过滤器来进行判断。 
我们这里将原始长链接与 UUID 字符串进行拼接，然后拼接后的内容查询布隆过滤器，如果重复则继续拼接，直到生成一个不重复的短链接为止。

```java
String originUrl = requestParam.getOriginUrl();
originUrl += UUID.randomUUID().toString();
String shorUri = HashUtil.hashToBase62(originUrl);
```

### 1为什么不直接使用 UUID？  
>有位同学面试时被问到这个问题，其实是可以的。但是，有一个差强人意的理由，那就是生成 UUID 需要耗费时间，哪怕是极小的时间。  

这里的回答有**异议**：
目前的设计有一点**美中不足**，理想设计应该是先使用原始链接去生成，如果**发现冲突**了再使用拼接 UUID 方式解决冲突。  
改进后：
![image/Pasted image 20240328162756.png](/img/user/image/Pasted%20image%2020240328162756.png)
我重构的代码，存在一点性能问题：这个短链接除了第一次生成，**每次都需要经过至少两次循环来完成 UUID 的拼接**。
**回答**：实际上，重复的原始链接的可能性总体上还是相对较低的，额外的循环造成的性能损耗，相对于节省 UUID 生成的时间来说是可以接受的。

**所以：为什么不直接使用 UUID 呢？**

### 2为什么不只使用原始链接？  （应该不会有人问吧）
从性能上来说，仅使用原始链接是最好的，因为**不需要额外的时间**去生成UUID。  
但是因为业务上**允许原始链接重复**，而且即使不一样的原始链接也可能会发生 Hash 冲突，为了减少哈希冲突，最终还是需要拼接 UUID，这样可以确保即使是相同的原始链接，也会生成不同的短链接。


## 如果一直冲突怎么办？  
一直冲突的概率是很小的，但是针对这种概率事件，我们就要考虑到极端情况。为此，我们在代码加了一个判断变量，如果超过指定次数，就抛出异常。
```java
while (true) {
if (customGenerateCount > 10) {
throw new ServiceException("短链接频繁生成，请稍后再试");
...
}
```
