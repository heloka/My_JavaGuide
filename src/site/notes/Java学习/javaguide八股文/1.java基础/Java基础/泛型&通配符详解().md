---
{"title":"泛型&通配符详解","category":"Java","tag":"Java基础","dg-publish":true,"permalink":"/java/javaguide/1-java/java/and/","dgPassFrontmatter":true}
---

### 什么是泛型？有什么作⽤？
Java 泛型（Generics） 是 JDK 5 中引⼊的⼀个新特性。使⽤泛型参数，可以增强代码的
可读性以及稳定性。
编译器可以对泛型参数进⾏检测，并且通过泛型参数可以指定传⼊的对象类型。⽐如 `ArrayList<Persion> persons = new ArrayList<Persion>()` 这⾏代码就指明了该ArrayList 对象只能传⼊ Persion 对象，如果传⼊其他类型的对象就会报错
```java
AbstractList<E> extends AbstractList<E>
```
并且原⽣ List 返回类型是 Object ，需要⼿动转换类型才能使⽤，使⽤泛型后编
译器能够⾃动转换。
### 泛型的使⽤⽅式有哪⼏种？
泛型⼀般有三种使⽤⽅式:泛型类、泛型接⼝、泛型⽅法。
**1.泛型类：**
```java
public class Generic<T>{
//在实例化泛型类时，必须指定T的具体类型
    private T key;
    public Generic(T key) {
        this.key = key;
    }
    public T getKey(){
        return key;
    }
}
```
如何实例化泛型类：
```java
Generic<Integer> genericInteger = new Generic<Integer>(123456);
```
**2.泛型接⼝ ：**
```java
public interface Generator<T> {
    public T method();
}
```
实现泛型接⼝，不指定类型：
实现泛型接⼝，指定类型：
**3.泛型⽅法 ：**
```java
public <T> void printArray(T[] array) {
    for (T element : array) {
        System.out.print(element + " ");
    }
    System.out.println();
}
//这个泛型方法 `printArray` 接受一个泛型数组，并打印数组中的元素。它可以用于不同类型的数组，例如整数数组、字符串数组等。
```
使⽤：
```java
Integer[] intArray = { 1, 2, 3, 4, 5 };
String[] stringArray = { "Hello", "World" };
printArray(intArray); // 调用泛型方法，自动推断类型参数为 Integer
printArray(stringArray); // 调用泛型方法，自动推断类型参数为 String

```

### **项⽬中哪⾥⽤到了泛型？**
- ⾃定义接⼝**通⽤返回结果**   `CommonResult<T>` 通过参数 T 可根据具体的返回类型来动态指定结果的数据类型
- 定义 Excel 处理类 `ExcelUtil<T> `⽤于动态指定 Excel 导出的数据类型
- 构建集合⼯具类（参考 Collections 中的 sort, binarySearch ⽅法）。
### 什么是泛型擦除机制？为什么要擦除?
Java 的泛型是伪泛型，这是因为 Java 在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。
编译器会在编译期间会动态地将泛型 T 擦除为 Object 或将 T extends xxx 擦除为其限定类型 xxx 。
因此，泛型本质上其实还是编译器的⾏为，为了保证引⼊泛型机制但不创建新的类型，减少虚拟机的运⾏开销，编译器通过擦除将泛型类转化为⼀般类。

泛型擦除之后，`List<String>` 与` List<Integer>` 在编译以后都变成了 List 。
### 既然编译器要把泛型擦除，那为什么还要⽤泛型呢？⽤ Object 代替不⾏吗？
这个问题其实在变相考察**泛型的作⽤**：
 - 使⽤泛型可在编译期间进⾏类型检测。 
 - 使⽤ Object 类型需要⼿动添加强制类型转换，降低代码可读性，提⾼出错概率。 
 - 泛型可以使⽤⾃限定类型如 T extends Comparable 。
### 什么是桥方法？
 桥⽅法(Bridge Method) ⽤于继承泛型类时保证多态。
⚠注意 ：桥⽅法为编译器⾃动⽣成，⾮⼿写。
### 泛型有哪些限制？为什么？
- 泛型的限制⼀般是由**泛型擦除机制**导致的。擦除为 Object 后⽆法进⾏类型判断
- 只能声明不能实例化 T 类型变量。
- 泛型参数**不能是基本类型**。因为基本类型不是 Object ⼦类，应该⽤基本类型对应的引⽤类型代替。
- **不能实例化泛型数组**。因为Java的泛型在编译时会执行**类型擦除**，泛型类型信息会被擦除为Object类型，而数组需要在创建时确定元素的类型。
- 泛型⽆法使⽤ Instance of 和 getClass()  进⾏类型判断。
- 不能实现两个不同泛型参数的同⼀接⼝，擦除后多个⽗类的桥⽅法将冲突,桥⽅法⽤于继承泛型类时**保证多态**。
- 不能使⽤ static 修饰泛型变量

### 什么是通配符？有什么作⽤？
泛型类型是固定的，某些场景下使⽤起来不太灵活，于是，通配符就来了！通配符可以允许类型参数变化，⽤来解决泛型⽆法协变的问题。
举个例⼦：
```java
public void process(List<?> list) {
    // 可以处理任何类型的泛型列表
}
```

### 通配符 ？和常⽤的泛型 T 之间有什么区别？
- T 可以⽤于声明变量或常量⽽ ? 不⾏。
- T ⼀般⽤于声明泛型类或⽅法，通配符 ? ⼀般⽤于泛型⽅法的调⽤代码和形参。
- T 在编译期会被擦除为限定类型或 Object，通配符⽤于捕获具体类型。
### 什么是⽆界通配符？
⽆界通配符可以接收任何泛型类型数据，⽤于实现不依赖于具体类型参数的简单⽅法，可以捕获参数类型并交由泛型⽅法进⾏处理。
### `List<?> `和 List 有区别吗？
`List<?>` list 表示 list 是持有某种特定类型的 List，但是不知道具体是哪种类型。因此，我们添加元素进去的时候会报错。
List list 表示 list  是持有的元素的类型是 Object，因此可以添加任何类
型的对象，只不过编译器会有警告信息。
### 什么是上边界通配符？什么是下边界通配符？
在使⽤泛型的时候，我们还可以为传⼊的泛型类型实参进⾏上下边界的限制，如：类型实参只准传⼊某种类型的⽗类或某种类型的⼦类。
上边界通配符 extends 表示通配符可以接受 T 或 T 的子类类型。通常用于限制方法只能读取元素，不能修改元素。
举个例⼦：
```java
public void process(List<? extends Number> list) {
    // 可以处理 Number 或 Number 的子类列表
}
```

类型边界可以设置多个，还可以对 T 类型进⾏限制。

下边界通配符 super 表示通配符可以接受 T 或 T 的父类类型。通常用于限制方法只能添加元素，不能读取元素。
举个例⼦：
 ```java
 public void addElement(List<? super Integer> list) {
    // 可以添加 Integer 或 Integer 的父类元素
}
```
### ? extends xxx 和 ? super xxx 有什么区别?
两者接收参数的范围不同。并且，使⽤ ? extends xxx 声明的泛型参数只能调⽤ ge
t() ⽅法返回 xxx 类型，调⽤ set() 报错。使⽤ ? super xxx 声明的泛型参数
只能调⽤ set() ⽅法接收 xxx 类型，调⽤ get() 报错。
### T extends xxx 和 ? extends xxx ⼜有什么区别？
T extends xxx ⽤于定义泛型类和⽅法，擦除后为 xxx 类型， ? extends xxx ⽤
于声明⽅法形参，接收 xxx 和其⼦类型。
### `Class<?>` 和 Class 的区别？
直接使⽤ Class 的话会有⼀个类型警告，使⽤` Class<?>` 则没有，因为 Class 是⼀个泛型类，接收原⽣类型会产⽣警告
