---
{"dg-publish":true,"permalink":"/短链接-判断短链接是否存在为什么不使用Set结构？/"}
---

## 短链接业务  
我们使用布隆过滤器作为一个短链接的存储容器，并且每次生成时判断短链接是否已存在，但是会有一些误判率。  
那可能有同学和面试官就问了，为什么不使用 Set 结构去处理这种判重问题？性能又高，又不会有误判率。  
那我们基于使用 Set 结构可能存在的两个问题，说说为什么不用它。  

## 为什么不使用 Set 结构？  
### 1占用空间过大  
当使用布隆过滤器时，它使用了一个位数组来表示元素的存在性。这个位数组的长度通常会根据预期的元素数量进行设置。相比之下，Set 结构需要存储元素的实际值。  
因为 Set 结构需要存储实际的元素值。在内存中，每个元素都需要占用一定的空间。对于大量元素的情况，存储这些元素所需的内存空间会相应增加。  
举个例子来说明，假设我们有一个存储 1,000,000 个短链接的数据集。如果使用 Set 结构来存储这些短链接，每个短链接可能需要几十个字节的空间。这意味着存储这些元素可能需要数十兆字节的内存。  
相比之下，**使用布隆过滤器可以显著减少内存消耗**，从而节省大量内存空间。  
需要注意的是，布隆过滤器的位数组长度和哈希函数的数量会影响到误判率和内存消耗之间的权衡。较小的位数组和较少的哈希函数可能会降低内存消耗，但也会增加误判率。因此，在使用布隆过滤器时，需要根据实际需求和对误判率的容忍程度进行适当的配置。  

### 2大 Key 问题  
[[Java学习/javaguide八股文/3.数据库/redis/Redis常见面试题总结#Redis 的大 Key 如何处理\|Redis常见面试题总结#Redis 的大 Key 如何处理]]
设想，我们短链接中如果使用 Set，那么极有可能会发生一个 Set 存储数百万甚至上千万的元素，这就涉及到大 Key 问题。  
Redis 中的 "大 Key" 通常指的是一个占用较大内存空间的键（Key）。这可能会对 Redis 的性能产生负面影响，因为大 Key 可能导致内存碎片化、删除延迟以及网络传输时间延长等问题。  
"大 Key" 的概念相对主观，具体取决于应用程序的需求、硬件配置以及 Redis 实例的总内存大小。在一般情况下，如果一个键的数据量占用了大量的内存比例，可能就可以被认为是大 Key。  
具体的大小标准没有固定的规定，因为这取决于多个因素，我们可以在应用设计时按照一个简约的标准执行：  
- String Key 存储内容最多不允许超过 5MB。  
- LIST、SET、ZSET 等类型的 Key，成员数量最多不允许超过 20000。  
- Hash 类型的 Key，Key 数量参考上条。同时，内部 Key 对应的 Val 不应该过大，不然还是可能成为大 Key。  
以上观点参考了多家 Redis 开发规范，但就像上面说的，大 Key 的概念更多取决于应用程序需求、硬件配置以及实例总大小，**所以没有标准限制**。这点大家可以和面试官重点强调下。  

大 Key 可能会导致以下问题：  
- 内存碎片化：大 Key 占用的内存块较大，可能导致内存碎片化，从而影响 Redis 的内存使用效率。  
- 网络传输延迟：传输大 Key 的数据可能会导致较长的网络传输时间，特别是在进行备份、迁移或从节点同步等操作时。  
- 删除阻塞：在删除大 Key 的过程中，可能会导致其他操作的响应时间变长。这是因为在删除大 Key 时，需要遍历键中的所有元素，并在内部进行相应的清理操作。在此期间，其他操作会等待删除操作完成。  
- 持久化延迟：如果 Redis 实例使用了持久化机制（如 RDB 快照或 AOF 日志），删除大 Key 可能会导致持久化操作的延迟，因为持久化过程也需要处理大 Key 的数据。


短链接长度不是固定的嘛，为啥会有大key