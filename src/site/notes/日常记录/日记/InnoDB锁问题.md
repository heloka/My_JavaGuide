---
{"dg-publish":true,"permalink":"/日常记录/日记/InnoDB锁问题/"}
---

InnoDB 与 MyISAM 的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁。

### InnoDB 行锁实现方式
InnoDB 行锁是通过给索引上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！

### 关于死锁
MyISAM 表锁是 deadlock free 的，这是因为 MyISAM 总是一次获得所需的全部锁，要么全部满足，要么等待，因此不会出现死锁。但在 InnoDB 中，除单个 SQL 组成的事务外，锁是逐步获得的，这就决定了在 InnoDB 中发生死锁是可能的
![Pasted image 20240326100726.png](/img/user/image/Pasted%20image%2020240326100726.png)
如果能够在做其他处理的时候释放掉锁，应该就不会死锁了
在上面的例子中，两个事务都需要获得对方持有的排他锁才能继续完成事务，这种循环锁等待就是典型的死锁。

### 如何避免 InnoDb 死锁
死锁有四个必要条件：**互斥、占有且等待、不可强占用、循环等待**。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件，死锁就不会成立。所以在数据库层面，我们可以通过「打破循环等待条件」来解除死锁状态：  
- **设置事务等待锁的超时时间：**  当一个事务的等待时间超时后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。在 InnoDB 中，可以通过手动设置参数 `innodb_lock_wait_timeout` 来配置事务等待锁的超时时间。  
- **开启主动死锁检测：**  当系统检测到死锁时，会主动回滚死锁链条中的某一个事务，让其他事务继续执行，从而打破循环等待条件。将参数 `innodb_deadlock_detect` 设置为 `on`，表示开启主动死锁检测，这是默认开启的。
我们也可以从**业务的角度**来预防死锁，以下是几种常用方法：
1. **统一访问顺序**：不同的事务在访问一组表时，应尽量约定以**相同的顺序**访问，同样，在访问表中的行时，也尽量以**固定的顺序**存取表。这样可以大大减少死锁的机会。
2. **一次性申请足够级别的锁**：在事务中，更新记录时最好一次性请求足够级别的锁。比如，在修改数据时直接申请排他锁，而不是先申请共享锁再升级为排他锁，这样可以减少锁冲突和死锁的发生。
3. **使用较低的隔离级别**：尽量使用较低的隔离级别，在 `REPEATABLE-READ` 隔离级别下，如果两个线程同时对相同条件记录用 `SELECT... FOR UPDATE` 加排他锁，在没有符合该条件记录情况下，两个线程都会加锁成功。程序发现记录尚不存在，就试图插入一条新记录，如果两个线程都这么做，就会出现死锁。这种情况下，将隔离级别改成 `READ COMMITTED`，就可避免问题。